-- =====================================================
-- Migration: Helper Functions and Supporting Tables
-- Date: 2026-01-28
-- Description: 
--   - Create 3 helper functions
--   - Create deal_role_types table
--   - Create deals_clerk_orgs table
--   - Create document management tables
--   - Update access control functions with business logic
-- Note: deal_roles table will be created later after loans->deals rename
-- =====================================================

BEGIN;

-- =====================================================
-- PART 1: Create Helper Functions
-- =====================================================

-- Function: get_current_user_id()
-- Returns the current user's internal ID from users table
CREATE OR REPLACE FUNCTION public.get_current_user_id()
RETURNS bigint
LANGUAGE sql
SECURITY DEFINER
STABLE
AS $$
  SELECT id
  FROM public.users
  WHERE clerk_user_id = auth.uid()::text
  LIMIT 1;
$$;

COMMENT ON FUNCTION public.get_current_user_id() IS 
'Returns the internal user ID (bigint) for the current authenticated user';

-- Function: get_active_org_id()
-- Returns the active organization ID for the current user
CREATE OR REPLACE FUNCTION public.get_active_org_id()
RETURNS uuid
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
AS $$
DECLARE
  v_org_id uuid;
BEGIN
  -- TODO: Replace this with your logic for determining active org
  -- Options:
  -- 1. From request headers/context
  -- 2. From user's default org setting
  -- 3. From session/JWT claims
  
  -- Placeholder: return first org the user is a member of
  SELECT om.organization_id INTO v_org_id
  FROM public.organization_members om
  WHERE om.user_id = auth.uid()::text
  LIMIT 1;
  
  RETURN v_org_id;
END;
$$;

COMMENT ON FUNCTION public.get_active_org_id() IS 
'Returns the active organization ID (UUID) for the current user. TODO: Implement proper active org logic.';

-- Function: is_org_admin()
-- Checks if current user is an admin of the specified organization
CREATE OR REPLACE FUNCTION public.is_org_admin(p_org_id uuid)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1
    FROM public.organization_members om
    WHERE om.organization_id = p_org_id
      AND om.user_id = auth.uid()::text
      AND om.role = 'admin'
  );
END;
$$;

COMMENT ON FUNCTION public.is_org_admin(uuid) IS 
'Returns true if the current user is an admin of the specified organization';

-- =====================================================
-- PART 2: Create deal_role_types table
-- =====================================================
CREATE TABLE IF NOT EXISTS public.deal_role_types (
  id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  code text NOT NULL,
  name text NOT NULL,
  description text NULL,
  allows_multiple boolean NULL DEFAULT true,
  display_order integer NULL,
  is_active boolean NULL DEFAULT true,
  created_at timestamp with time zone NULL DEFAULT now(),
  CONSTRAINT deal_role_types_pkey PRIMARY KEY (id),
  CONSTRAINT deal_role_types_code_key UNIQUE (code)
) TABLESPACE pg_default;

-- =====================================================
-- PART 3: Create deals_clerk_orgs table
-- (Maps deals to organizations)
-- =====================================================
CREATE TABLE IF NOT EXISTS public.deals_clerk_orgs (
  id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  deal_id uuid NOT NULL,
  clerk_org_id uuid NOT NULL,
  CONSTRAINT deals_orgs_pkey PRIMARY KEY (id),
  CONSTRAINT deals_orgs_deal_id_clerk_org_id_key UNIQUE (deal_id, clerk_org_id),
  CONSTRAINT deals_clerk_orgs_clerk_org_id_fkey 
    FOREIGN KEY (clerk_org_id) REFERENCES organizations(id) ON DELETE CASCADE,
  CONSTRAINT deals_clerk_orgs_deal_id_fkey 
    FOREIGN KEY (deal_id) REFERENCES loans(id)
) TABLESPACE pg_default;

CREATE INDEX IF NOT EXISTS idx_deals_orgs_clerk_org_id 
  ON public.deals_clerk_orgs USING btree (clerk_org_id) 
  TABLESPACE pg_default;

CREATE INDEX IF NOT EXISTS idx_deals_orgs_deal_id 
  ON public.deals_clerk_orgs USING btree (deal_id) 
  TABLESPACE pg_default;

-- =====================================================
-- PART 4: Create document_categories_user_order table
-- =====================================================
CREATE TABLE IF NOT EXISTS public.document_categories_user_order (
  id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  clerk_user_id text NOT NULL,
  document_categories_id bigint NOT NULL,
  display_order integer NOT NULL,
  created_at timestamp with time zone NULL DEFAULT now(),
  updated_at timestamp with time zone NULL DEFAULT now(),
  CONSTRAINT user_pref_document_categories_order_pkey PRIMARY KEY (id),
  CONSTRAINT userpref_doc_category_order_unique UNIQUE (clerk_user_id, document_categories_id),
  CONSTRAINT user_pref_document_categories_order_document_categories_id_fkey 
    FOREIGN KEY (document_categories_id) REFERENCES document_categories(id) ON DELETE CASCADE
) TABLESPACE pg_default;

CREATE INDEX IF NOT EXISTS idx_user_pref_doc_cat_order_clerk_user 
  ON public.document_categories_user_order USING btree (clerk_user_id) 
  TABLESPACE pg_default;

-- =====================================================
-- PART 5: Create document_access_permissions_global table
-- =====================================================
CREATE TABLE IF NOT EXISTS public.document_access_permissions_global (
  id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  deal_role_types_id bigint NOT NULL,
  document_categories_id bigint NOT NULL,
  can_view boolean NULL DEFAULT false,
  can_insert boolean NULL DEFAULT false,
  can_upload boolean NULL DEFAULT false,
  can_delete boolean NULL DEFAULT false,
  created_at timestamp with time zone NULL DEFAULT now(),
  CONSTRAINT document_access_permissions_global_pkey PRIMARY KEY (id),
  CONSTRAINT document_access_permissions_global_unique 
    UNIQUE (deal_role_types_id, document_categories_id),
  CONSTRAINT document_access_permissions_global_deal_role_types_id_fkey 
    FOREIGN KEY (deal_role_types_id) REFERENCES deal_role_types(id) ON DELETE CASCADE,
  CONSTRAINT document_access_permissions_global_document_categories_id_fkey 
    FOREIGN KEY (document_categories_id) REFERENCES document_categories(id) ON DELETE CASCADE
) TABLESPACE pg_default;

CREATE INDEX IF NOT EXISTS idx_doc_access_perm_global_role 
  ON public.document_access_permissions_global USING btree (deal_role_types_id) 
  TABLESPACE pg_default;

CREATE INDEX IF NOT EXISTS idx_doc_access_perm_global_category 
  ON public.document_access_permissions_global USING btree (document_categories_id) 
  TABLESPACE pg_default;

-- =====================================================
-- PART 6: Create document_access_permissions table (org-specific)
-- =====================================================
CREATE TABLE IF NOT EXISTS public.document_access_permissions (
  id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  clerk_org_id uuid NOT NULL,
  deal_role_types_id bigint NOT NULL,
  document_categories_id bigint NOT NULL,
  can_view boolean NOT NULL DEFAULT false,
  can_insert boolean NOT NULL DEFAULT false,
  can_upload boolean NOT NULL DEFAULT false,
  can_delete boolean NOT NULL DEFAULT false,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_by_user_id bigint NULL,
  updated_by_clerk_sub text NULL,
  CONSTRAINT document_access_permissions_pkey PRIMARY KEY (id),
  CONSTRAINT document_access_permissions_unique 
    UNIQUE (clerk_org_id, deal_role_types_id, document_categories_id),
  CONSTRAINT document_access_permissions_clerk_org_id_fkey 
    FOREIGN KEY (clerk_org_id) REFERENCES organizations(id) ON DELETE CASCADE,
  CONSTRAINT document_access_permissions_deal_role_types_id_fkey 
    FOREIGN KEY (deal_role_types_id) REFERENCES deal_role_types(id) ON DELETE CASCADE,
  CONSTRAINT document_access_permissions_document_categories_id_fkey 
    FOREIGN KEY (document_categories_id) REFERENCES document_categories(id) ON DELETE CASCADE,
  CONSTRAINT document_access_permissions_updated_by_user_id_fkey 
    FOREIGN KEY (updated_by_user_id) REFERENCES users(id) ON DELETE SET NULL
) TABLESPACE pg_default;

CREATE INDEX IF NOT EXISTS idx_doc_access_perm_lookup 
  ON public.document_access_permissions USING btree (
    clerk_org_id,
    deal_role_types_id,
    document_categories_id
  ) TABLESPACE pg_default;

-- Note: clerk_org_id is UUID type to match organizations.id

-- =====================================================
-- PART 7: Create document_tags table
-- =====================================================
CREATE TABLE IF NOT EXISTS public.document_tags (
  id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  name text NOT NULL,
  slug text NOT NULL,
  description text NULL,
  color text NULL,
  created_at timestamp with time zone NULL DEFAULT now(),
  created_by bigint NULL,
  updated_at timestamp with time zone NULL DEFAULT now(),
  CONSTRAINT document_tags_pkey PRIMARY KEY (id),
  CONSTRAINT document_tags_slug_key UNIQUE (slug),
  CONSTRAINT document_tags_created_by_fkey 
    FOREIGN KEY (created_by) REFERENCES users(id) ON DELETE SET NULL
) TABLESPACE pg_default;

CREATE INDEX IF NOT EXISTS idx_document_tags_slug 
  ON public.document_tags USING btree (slug) 
  TABLESPACE pg_default;

CREATE INDEX IF NOT EXISTS idx_document_tags_name 
  ON public.document_tags USING btree (name) 
  TABLESPACE pg_default;

CREATE INDEX IF NOT EXISTS idx_document_tags_created_by 
  ON public.document_tags USING btree (created_by) 
  TABLESPACE pg_default;

-- =====================================================
-- PART 8: Create document_roles table
-- =====================================================
CREATE TABLE IF NOT EXISTS public.document_roles (
  id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  role_name text NOT NULL,
  CONSTRAINT document_roles_pkey PRIMARY KEY (id),
  CONSTRAINT document_roles_role_name_key UNIQUE (role_name)
) TABLESPACE pg_default;

-- =====================================================
-- PART 9: Create document_files_tags junction table
-- =====================================================
CREATE TABLE IF NOT EXISTS public.document_files_tags (
  id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  document_file_id bigint NOT NULL,
  document_tag_id bigint NOT NULL,
  created_at timestamp with time zone NULL DEFAULT now(),
  created_by bigint NULL,
  CONSTRAINT document_files_tags_pkey PRIMARY KEY (id),
  CONSTRAINT document_files_tags_document_file_id_document_tag_id_key 
    UNIQUE (document_file_id, document_tag_id),
  CONSTRAINT document_files_tags_created_by_fkey 
    FOREIGN KEY (created_by) REFERENCES users(id) ON DELETE SET NULL,
  CONSTRAINT document_files_tags_document_file_id_fkey 
    FOREIGN KEY (document_file_id) REFERENCES document_files(id) ON DELETE CASCADE,
  CONSTRAINT document_files_tags_document_tag_id_fkey 
    FOREIGN KEY (document_tag_id) REFERENCES document_tags(id) ON DELETE CASCADE
) TABLESPACE pg_default;

CREATE INDEX IF NOT EXISTS idx_document_files_tags_doc 
  ON public.document_files_tags USING btree (document_file_id) 
  TABLESPACE pg_default;

CREATE INDEX IF NOT EXISTS idx_document_files_tags_tag 
  ON public.document_files_tags USING btree (document_tag_id) 
  TABLESPACE pg_default;

CREATE INDEX IF NOT EXISTS idx_document_files_tags_created_by 
  ON public.document_files_tags USING btree (created_by) 
  TABLESPACE pg_default;

-- =====================================================
-- PART 10: Create document_roles_files junction table
-- =====================================================
CREATE TABLE IF NOT EXISTS public.document_roles_files (
  id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  document_files_id bigint NOT NULL,
  document_roles_id bigint NOT NULL,
  CONSTRAINT document_roles_files_pkey PRIMARY KEY (id),
  CONSTRAINT document_roles_files_document_files_id_fkey 
    FOREIGN KEY (document_files_id) REFERENCES document_files(id) ON UPDATE CASCADE ON DELETE CASCADE,
  CONSTRAINT document_roles_files_document_roles_id_fkey 
    FOREIGN KEY (document_roles_id) REFERENCES document_roles(id) ON UPDATE CASCADE ON DELETE CASCADE
) TABLESPACE pg_default;

-- =====================================================
-- PART 11: Create document_files_clerk_orgs table
-- =====================================================
CREATE TABLE IF NOT EXISTS public.document_files_clerk_orgs (
  id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  document_file_id bigint NOT NULL,
  clerk_org_id uuid NOT NULL,
  created_at timestamp with time zone NULL DEFAULT now(),
  created_by text NULL,
  CONSTRAINT document_files_clerk_orgs_pkey PRIMARY KEY (id),
  CONSTRAINT document_files_clerk_orgs_document_file_id_clerk_org_id_key 
    UNIQUE (document_file_id, clerk_org_id),
  CONSTRAINT document_files_clerk_orgs_clerk_org_id_fkey 
    FOREIGN KEY (clerk_org_id) REFERENCES organizations(id) ON DELETE CASCADE,
  CONSTRAINT document_files_clerk_orgs_document_file_id_fkey 
    FOREIGN KEY (document_file_id) REFERENCES document_files(id) ON DELETE CASCADE
) TABLESPACE pg_default;

CREATE INDEX IF NOT EXISTS idx_document_files_clerk_orgs_doc 
  ON public.document_files_clerk_orgs USING btree (document_file_id) 
  TABLESPACE pg_default;

CREATE INDEX IF NOT EXISTS idx_document_files_clerk_orgs_org 
  ON public.document_files_clerk_orgs USING btree (clerk_org_id) 
  TABLESPACE pg_default;

-- =====================================================
-- PART 12: Create document_files_clerk_users table
-- =====================================================
CREATE TABLE IF NOT EXISTS public.document_files_clerk_users (
  id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  document_file_id bigint NOT NULL,
  clerk_user_id bigint NOT NULL,
  created_at timestamp with time zone NULL DEFAULT now(),
  created_by text NULL,
  CONSTRAINT document_files_clerk_users_pkey PRIMARY KEY (id),
  CONSTRAINT document_files_clerk_users_document_file_id_clerk_user_id_key 
    UNIQUE (document_file_id, clerk_user_id),
  CONSTRAINT document_files_clerk_users_clerk_user_id_fkey 
    FOREIGN KEY (clerk_user_id) REFERENCES users(id) ON DELETE CASCADE,
  CONSTRAINT document_files_clerk_users_document_file_id_fkey 
    FOREIGN KEY (document_file_id) REFERENCES document_files(id) ON DELETE CASCADE
) TABLESPACE pg_default;

CREATE INDEX IF NOT EXISTS idx_document_files_clerk_users_doc 
  ON public.document_files_clerk_users USING btree (document_file_id) 
  TABLESPACE pg_default;

CREATE INDEX IF NOT EXISTS idx_document_files_clerk_users_user 
  ON public.document_files_clerk_users USING btree (clerk_user_id) 
  TABLESPACE pg_default;

-- =====================================================
-- PART 13: Create document_files_entities table
-- =====================================================
CREATE TABLE IF NOT EXISTS public.document_files_entities (
  id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  document_file_id bigint NOT NULL,
  entity_id uuid NOT NULL,
  created_at timestamp with time zone NULL DEFAULT now(),
  created_by text NULL,
  CONSTRAINT document_files_entities_pkey PRIMARY KEY (id),
  CONSTRAINT document_files_entities_document_file_id_entity_id_key 
    UNIQUE (document_file_id, entity_id),
  CONSTRAINT document_files_entities_entity_id_fkey 
    FOREIGN KEY (entity_id) REFERENCES entities(id) ON DELETE CASCADE,
  CONSTRAINT document_files_entities_document_file_id_fkey 
    FOREIGN KEY (document_file_id) REFERENCES document_files(id) ON DELETE CASCADE
) TABLESPACE pg_default;

CREATE INDEX IF NOT EXISTS idx_document_files_entities_doc 
  ON public.document_files_entities USING btree (document_file_id) 
  TABLESPACE pg_default;

CREATE INDEX IF NOT EXISTS idx_document_files_entities_entity 
  ON public.document_files_entities USING btree (entity_id) 
  TABLESPACE pg_default;

-- =====================================================
-- PART 14: Update can_access_deal_document() with business logic
-- NOTE: This is v1 without deal_roles check (table doesn't exist yet)
-- Will be updated in next migration after deal_roles table is created
-- =====================================================
CREATE OR REPLACE FUNCTION public.can_access_deal_document(
  p_deal_id uuid,
  p_document_category_id bigint,
  p_action text
)
RETURNS boolean
LANGUAGE sql
SECURITY DEFINER
STABLE
AS $$
  SELECT
    CASE
      WHEN p_action NOT IN ('view','insert','upload','delete') THEN false
      ELSE (
        public.is_internal_admin()
        OR (
          public.get_active_org_id() IS NOT NULL

          -- Must be member of active org
          AND EXISTS (
            SELECT 1
            FROM public.organization_members m
            WHERE m.user_id = auth.uid()::text
              AND m.organization_id = public.get_active_org_id()
          )

          -- Deal must belong to active org if mapped
          AND (
            NOT EXISTS (
              SELECT 1
              FROM public.deals_clerk_orgs dorg
              WHERE dorg.deal_id = p_deal_id
            )
            OR EXISTS (
              SELECT 1
              FROM public.deals_clerk_orgs dorg
              WHERE dorg.deal_id = p_deal_id
                AND dorg.clerk_org_id = public.get_active_org_id()
            )
          )

          -- Org-admin bypass only after dealâ†”org validation
          AND public.is_org_admin(public.get_active_org_id())
          
          -- TODO: Add deal_roles permission check after deal_roles table is created
          -- Will be enabled in next migration after loans->deals rename
        )
      )
    END;
$$;

-- =====================================================
-- PART 15: Update can_access_deal_document_by_code() wrapper
-- =====================================================
CREATE OR REPLACE FUNCTION public.can_access_deal_document_by_code(
  p_deal_id uuid,
  p_document_category_code text,
  p_action text
)
RETURNS boolean
LANGUAGE sql
SECURITY DEFINER
STABLE
AS $$
  WITH cat AS (
    SELECT id
    FROM public.document_categories
    WHERE code = p_document_category_code
  )
  SELECT CASE
    WHEN (SELECT count(*) FROM cat) = 1
      THEN public.can_access_deal_document(p_deal_id, (SELECT id FROM cat), p_action)
    ELSE false
  END;
$$;

-- =====================================================
-- Grant permissions
-- =====================================================
GRANT EXECUTE ON FUNCTION public.get_current_user_id() TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_active_org_id() TO authenticated;
GRANT EXECUTE ON FUNCTION public.is_org_admin(uuid) TO authenticated;

COMMIT;

-- =====================================================
-- Post-migration notes:
-- - Created 3 helper functions
-- - Created deal_role_types table
-- - Created deals_clerk_orgs table (maps deals to orgs)
-- - Created document management tables (tags, permissions, etc.)
-- - Updated access control functions with full business logic
-- 
-- NOTE: deal_roles table NOT created yet - waiting for loans->deals rename
-- 
-- NEXT STEPS:
-- 1. Rename loans table to deals (separate migration)
-- 2. Create deal_roles table (references deals, not loans)
-- 3. Implement get_active_org_id() logic (currently placeholder)
-- =====================================================
