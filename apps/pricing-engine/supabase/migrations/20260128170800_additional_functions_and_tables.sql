-- =====================================================
-- Migration: Additional Helper Functions and Tables
-- Date: 2026-01-28
-- Description:
--   - Update get_active_org_id() with JWT claim logic
--   - Create additional helper functions
--   - Create missing linking tables
-- =====================================================

BEGIN;

-- =====================================================
-- PART 1: Update get_active_org_id() with JWT claim logic
-- =====================================================
CREATE OR REPLACE FUNCTION public.get_active_org_id()
RETURNS uuid
LANGUAGE sql
SECURITY DEFINER
STABLE
AS $$
  -- Clerk stores the active org in 'org_id' claim when user switches orgs
  SELECT co.id
  FROM public.organizations co
  WHERE co.clerk_organization_id = (auth.jwt() ->> 'org_id')
  LIMIT 1;
$$;

COMMENT ON FUNCTION public.get_active_org_id() IS 
'Returns the active organization ID (UUID) from JWT org_id claim';

-- =====================================================
-- PART 2: Create get_clerk_user_id() function
-- =====================================================
CREATE OR REPLACE FUNCTION public.get_clerk_user_id()
RETURNS text
LANGUAGE sql
SECURITY DEFINER
STABLE
AS $$
  SELECT auth.uid()::text;
$$;

COMMENT ON FUNCTION public.get_clerk_user_id() IS 
'Returns the Clerk user ID (text) for the current authenticated user';

-- =====================================================
-- PART 3: Create generate_tag_slug() function
-- =====================================================
CREATE OR REPLACE FUNCTION public.generate_tag_slug(tag_name text)
RETURNS text
LANGUAGE plpgsql
IMMUTABLE
AS $$
BEGIN
  -- Convert to lowercase, replace spaces with hyphens, remove special chars
  RETURN lower(regexp_replace(regexp_replace(trim(tag_name), '\s+', '-', 'g'), '[^a-z0-9\-]', '', 'g'));
END;
$$;

COMMENT ON FUNCTION public.generate_tag_slug(text) IS 
'Generates a URL-safe slug from a tag name';

-- =====================================================
-- PART 4: Create document_files_deals linking table
-- =====================================================
CREATE TABLE IF NOT EXISTS public.document_files_deals (
  id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  document_file_id bigint NOT NULL,
  deal_id uuid NOT NULL,
  created_at timestamp with time zone NULL DEFAULT now(),
  created_by text NULL,
  CONSTRAINT document_files_deals_pkey PRIMARY KEY (id),
  CONSTRAINT document_files_deals_document_file_id_deal_id_key 
    UNIQUE (document_file_id, deal_id),
  CONSTRAINT document_files_deals_document_file_id_fkey 
    FOREIGN KEY (document_file_id) REFERENCES document_files(id) ON DELETE CASCADE,
  CONSTRAINT document_files_deals_deal_id_fkey 
    FOREIGN KEY (deal_id) REFERENCES deals(id) ON DELETE CASCADE
) TABLESPACE pg_default;

CREATE INDEX IF NOT EXISTS idx_document_files_deals_doc 
  ON public.document_files_deals USING btree (document_file_id) 
  TABLESPACE pg_default;

CREATE INDEX IF NOT EXISTS idx_document_files_deals_deal 
  ON public.document_files_deals USING btree (deal_id) 
  TABLESPACE pg_default;

-- =====================================================
-- PART 5: Create document_files_borrowers linking table
-- (Conditional - only if borrowers table exists)
-- =====================================================
DO $$ BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'borrowers') THEN
    CREATE TABLE IF NOT EXISTS public.document_files_borrowers (
      id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
      document_file_id bigint NOT NULL,
      borrower_id uuid NOT NULL,
      created_at timestamp with time zone NULL DEFAULT now(),
      created_by text NULL,
      CONSTRAINT document_files_borrowers_pkey PRIMARY KEY (id),
      CONSTRAINT document_files_borrowers_document_file_id_borrower_id_key 
        UNIQUE (document_file_id, borrower_id),
      CONSTRAINT document_files_borrowers_document_file_id_fkey 
        FOREIGN KEY (document_file_id) REFERENCES document_files(id) ON DELETE CASCADE,
      CONSTRAINT document_files_borrowers_borrower_id_fkey 
        FOREIGN KEY (borrower_id) REFERENCES borrowers(id) ON DELETE CASCADE
    );

    CREATE INDEX IF NOT EXISTS idx_document_files_borrowers_doc 
      ON public.document_files_borrowers USING btree (document_file_id);

    CREATE INDEX IF NOT EXISTS idx_document_files_borrowers_borrower 
      ON public.document_files_borrowers USING btree (borrower_id);

    RAISE NOTICE 'Created document_files_borrowers table';
  ELSE
    RAISE NOTICE 'borrowers table does not exist, skipping document_files_borrowers';
  END IF;
END $$;

-- =====================================================
-- PART 6: Create document_files_guarantors linking table
-- (Conditional - only if guarantors table exists)
-- =====================================================
DO $$ BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'guarantors') THEN
    CREATE TABLE IF NOT EXISTS public.document_files_guarantors (
      id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
      document_file_id bigint NOT NULL,
      guarantor_id uuid NOT NULL,
      created_at timestamp with time zone NULL DEFAULT now(),
      created_by text NULL,
      CONSTRAINT document_files_guarantors_pkey PRIMARY KEY (id),
      CONSTRAINT document_files_guarantors_document_file_id_guarantor_id_key 
        UNIQUE (document_file_id, guarantor_id),
      CONSTRAINT document_files_guarantors_document_file_id_fkey 
        FOREIGN KEY (document_file_id) REFERENCES document_files(id) ON DELETE CASCADE,
      CONSTRAINT document_files_guarantors_guarantor_id_fkey 
        FOREIGN KEY (guarantor_id) REFERENCES guarantors(id) ON DELETE CASCADE
    );

    CREATE INDEX IF NOT EXISTS idx_document_files_guarantors_doc 
      ON public.document_files_guarantors USING btree (document_file_id);

    CREATE INDEX IF NOT EXISTS idx_document_files_guarantors_guarantor 
      ON public.document_files_guarantors USING btree (guarantor_id);

    RAISE NOTICE 'Created document_files_guarantors table';
  ELSE
    RAISE NOTICE 'guarantors table does not exist, skipping document_files_guarantors';
  END IF;
END $$;

-- =====================================================
-- PART 7: Create document_file_deal_ids() function
-- Returns all deal IDs linked to a document
-- =====================================================
CREATE OR REPLACE FUNCTION public.document_file_deal_ids(p_document_file_id bigint)
RETURNS TABLE(deal_id uuid)
LANGUAGE sql
SECURITY DEFINER
STABLE
AS $$
  SELECT dfd.deal_id
  FROM public.document_files_deals dfd
  WHERE dfd.document_file_id = p_document_file_id;
$$;

COMMENT ON FUNCTION public.document_file_deal_ids(bigint) IS 
'Returns all deal IDs linked to a document file';

-- =====================================================
-- PART 8: Create finalize_document_upload() function
-- =====================================================
CREATE OR REPLACE FUNCTION public.finalize_document_upload(
  p_document_file_id bigint,
  p_file_size bigint DEFAULT NULL
)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- Only the uploader can finalize their own fresh doc
  IF NOT EXISTS (
    SELECT 1 FROM public.document_files
    WHERE id = p_document_file_id
      AND uploaded_by = public.get_clerk_user_id()
      AND uploaded_at IS NULL
  ) THEN
    RAISE EXCEPTION 'Permission denied or document already finalized';
  END IF;

  UPDATE public.document_files
  SET uploaded_at = now(),
      file_size = COALESCE(p_file_size, file_size)
  WHERE id = p_document_file_id;

  RETURN true;
END;
$$;

COMMENT ON FUNCTION public.finalize_document_upload(bigint, bigint) IS 
'Finalizes a document upload by setting uploaded_at timestamp. Only uploader can finalize.';

-- =====================================================
-- PART 9: Create can_access_document() function
-- This checks by document_file_id (different from can_access_deal_document)
-- =====================================================
CREATE OR REPLACE FUNCTION public.can_access_document(
  p_document_file_id bigint,
  p_action text
)
RETURNS boolean
LANGUAGE sql
SECURITY DEFINER
STABLE
AS $$
  WITH df AS (
    SELECT id, document_category_id, uploaded_by, uploaded_at
    FROM public.document_files
    WHERE id = p_document_file_id
  )
  SELECT
    CASE
      WHEN p_action NOT IN ('view','insert','upload','delete') THEN false
      ELSE (
        public.is_internal_admin()

        -- org admins: full VIEW access to docs explicitly linked to the active org
        OR (
          p_action = 'view'
          AND public.is_org_admin(public.get_active_org_id())
          AND EXISTS (
            SELECT 1
            FROM public.document_files_clerk_orgs dfco
            WHERE dfco.document_file_id = p_document_file_id
              AND dfco.clerk_org_id = public.get_active_org_id()
          )
        )

        -- uploader can view
        OR (
          p_action = 'view'
          AND EXISTS (
            SELECT 1 FROM df
            WHERE df.uploaded_by = public.get_clerk_user_id()
          )
        )

        -- uploader can upload to their own fresh doc (uploaded_at IS NULL means not yet uploaded)
        OR (
          p_action = 'upload'
          AND EXISTS (
            SELECT 1 FROM df
            WHERE df.uploaded_by = public.get_clerk_user_id()
              AND df.uploaded_at IS NULL
          )
        )

        -- direct user link can view (view-only by design)
        OR (
          p_action = 'view'
          AND EXISTS (
            SELECT 1
            FROM public.document_files_clerk_users dfcu
            WHERE dfcu.document_file_id = p_document_file_id
              AND dfcu.clerk_user_id = public.get_current_user_id()
          )
        )

        -- direct org link can view (must be member of active org)
        OR (
          p_action = 'view'
          AND public.get_active_org_id() IS NOT NULL
          AND EXISTS (
            SELECT 1
            FROM public.document_files_clerk_orgs dfco
            JOIN public.organization_members m
              ON m.organization_id = dfco.clerk_org_id
             AND m.user_id = auth.uid()::text
            WHERE dfco.document_file_id = p_document_file_id
              AND dfco.clerk_org_id = public.get_active_org_id()
          )
        )

        -- deal-derived permission (covers docs linked to borrower/guarantor/company/property)
        OR EXISTS (
          SELECT 1
          FROM df
          JOIN public.document_file_deal_ids(p_document_file_id) d ON true
          WHERE df.document_category_id IS NOT NULL
            AND public.can_access_deal_document(d.deal_id, df.document_category_id, p_action)
        )
      )
    END;
$$;

COMMENT ON FUNCTION public.can_access_document(bigint, text) IS 
'Checks if current user can access a specific document file. Uses document_file_id instead of deal_id.';

-- =====================================================
-- PART 10: Create get_deal_documents() function
-- =====================================================
CREATE OR REPLACE FUNCTION public.get_deal_documents(p_deal_id uuid)
RETURNS SETOF public.document_files
LANGUAGE sql
SECURITY DEFINER
STABLE
AS $$
  SELECT df.*
  FROM public.document_files df
  JOIN public.document_files_deals dfd
    ON dfd.document_file_id = df.id
  WHERE dfd.deal_id = p_deal_id
  ORDER BY df.created_at DESC;
$$;

COMMENT ON FUNCTION public.get_deal_documents(uuid) IS 
'Returns all document files linked to a specific deal';

-- =====================================================
-- PART 11: Create create_document_with_deal_link() function
-- =====================================================
CREATE OR REPLACE FUNCTION public.create_document_with_deal_link(
  p_deal_id uuid,
  p_document_category_id bigint,
  p_document_name text,
  p_original_filename text,
  p_storage_bucket text,
  p_file_type text DEFAULT NULL,
  p_file_size bigint DEFAULT NULL
)
RETURNS TABLE(document_id bigint, storage_bucket text, storage_path text)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_doc_id bigint;
  v_active_org_id uuid;
  v_active_org_clerk_id text;
  v_path text;
BEGIN
  -- 1) Bucket whitelist
  IF p_storage_bucket <> 'documents' THEN
    RAISE EXCEPTION 'Invalid storage_bucket: must be documents';
  END IF;

  -- 2) Validate org context exists
  v_active_org_id := public.get_active_org_id();
  IF v_active_org_id IS NULL THEN
    RAISE EXCEPTION 'No active org context';
  END IF;

  -- 3) Clerk org id string from JWT (adjust claim name if needed)
  v_active_org_clerk_id := (auth.jwt() ->> 'org_id');
  IF v_active_org_clerk_id IS NULL THEN
    RAISE EXCEPTION 'Missing org_id in JWT';
  END IF;

  -- 4) Permission check (insert doc for deal/category)
  IF NOT public.can_access_deal_document(p_deal_id, p_document_category_id, 'insert') THEN
    RAISE EXCEPTION 'Permission denied: cannot insert documents for this deal/category';
  END IF;

  -- 5) Create doc row first (storage_path set after we get id)
  INSERT INTO public.document_files (
    document_name,
    document_category_id,
    storage_bucket,
    storage_path,
    file_type,
    file_size,
    uploaded_by
  ) VALUES (
    p_document_name,
    p_document_category_id,
    p_storage_bucket,
    NULL,  -- set after we have the id
    p_file_type,
    p_file_size,
    public.get_clerk_user_id()
  ) RETURNING id INTO v_doc_id;

  -- 6) Deterministic path: orgs/<clerk_org_id>/df/<doc_id>/<filename>
  v_path := format('orgs/%s/df/%s/%s', v_active_org_clerk_id, v_doc_id, p_original_filename);

  UPDATE public.document_files
  SET storage_path = v_path
  WHERE id = v_doc_id;

  -- 7) Create deal link
  INSERT INTO public.document_files_deals (document_file_id, deal_id)
  VALUES (v_doc_id, p_deal_id);

  -- 8) Return result for client to use for upload
  RETURN QUERY SELECT v_doc_id, p_storage_bucket, v_path;
END;
$$;

COMMENT ON FUNCTION public.create_document_with_deal_link IS 
'Creates a document record with deal link and returns upload path';

-- =====================================================
-- PART 12: Create create_document_with_subject_link() function
-- =====================================================
CREATE OR REPLACE FUNCTION public.create_document_with_subject_link(
  p_document_category_id bigint,
  p_document_name text,
  p_original_filename text,
  p_storage_bucket text,
  p_subject_type text DEFAULT NULL,
  p_subject_id uuid DEFAULT NULL,
  p_file_type text DEFAULT NULL,
  p_file_size bigint DEFAULT NULL
)
RETURNS TABLE(document_id bigint, storage_bucket text, storage_path text)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_doc_id bigint;
  v_active_org_id uuid;
  v_active_org_clerk_id text;
  v_path text;
BEGIN
  -- 1) Bucket whitelist
  IF p_storage_bucket <> 'documents' THEN
    RAISE EXCEPTION 'Invalid storage_bucket: must be documents';
  END IF;

  -- 2) Validate org context exists
  v_active_org_id := public.get_active_org_id();
  IF v_active_org_id IS NULL THEN
    RAISE EXCEPTION 'No active org context';
  END IF;

  -- 3) Clerk org id string from JWT
  v_active_org_clerk_id := (auth.jwt() ->> 'org_id');
  IF v_active_org_clerk_id IS NULL THEN
    RAISE EXCEPTION 'Missing org_id in JWT';
  END IF;

  -- 4) Permission check: only org admins or internal admins can upload pre-deal docs
  IF NOT (public.is_internal_admin() OR public.is_org_admin(v_active_org_id)) THEN
    RAISE EXCEPTION 'Permission denied: must be org admin or internal admin for pre-deal uploads';
  END IF;

  -- 5) Validate subject type if provided
  IF p_subject_type IS NOT NULL AND p_subject_type NOT IN ('borrower', 'guarantor') THEN
    RAISE EXCEPTION 'Invalid subject_type: must be borrower or guarantor';
  END IF;

  IF p_subject_type IS NOT NULL AND p_subject_id IS NULL THEN
    RAISE EXCEPTION 'subject_id required when subject_type is provided';
  END IF;

  -- 6) Create doc row first (storage_path set after we get id)
  INSERT INTO public.document_files (
    document_name,
    document_category_id,
    storage_bucket,
    storage_path,
    file_type,
    file_size,
    uploaded_by
  ) VALUES (
    p_document_name,
    p_document_category_id,
    p_storage_bucket,
    NULL,
    p_file_type,
    p_file_size,
    public.get_clerk_user_id()
  ) RETURNING id INTO v_doc_id;

  -- 7) Deterministic path: orgs/<clerk_org_id>/df/<doc_id>/<filename>
  v_path := format('orgs/%s/df/%s/%s', v_active_org_clerk_id, v_doc_id, p_original_filename);

  UPDATE public.document_files
  SET storage_path = v_path
  WHERE id = v_doc_id;

  -- 8) Create org ownership link
  INSERT INTO public.document_files_clerk_orgs (document_file_id, clerk_org_id)
  VALUES (v_doc_id, v_active_org_id);

  -- 9) Create subject link if provided
  IF p_subject_type = 'borrower' THEN
    INSERT INTO public.document_files_borrowers (document_file_id, borrower_id)
    VALUES (v_doc_id, p_subject_id);
  ELSIF p_subject_type = 'guarantor' THEN
    INSERT INTO public.document_files_guarantors (document_file_id, guarantor_id)
    VALUES (v_doc_id, p_subject_id);
  END IF;

  -- 10) Return result for client to use for upload
  RETURN QUERY SELECT v_doc_id, p_storage_bucket, v_path;
END;
$$;

COMMENT ON FUNCTION public.create_document_with_subject_link IS 
'Creates a document record with optional subject (borrower/guarantor) link for pre-deal uploads';

-- =====================================================
-- Grant execute permissions
-- =====================================================
GRANT EXECUTE ON FUNCTION public.get_clerk_user_id() TO authenticated;
GRANT EXECUTE ON FUNCTION public.generate_tag_slug(text) TO authenticated;
GRANT EXECUTE ON FUNCTION public.document_file_deal_ids(bigint) TO authenticated;
GRANT EXECUTE ON FUNCTION public.finalize_document_upload(bigint, bigint) TO authenticated;
GRANT EXECUTE ON FUNCTION public.can_access_document(bigint, text) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_deal_documents(uuid) TO authenticated;
GRANT EXECUTE ON FUNCTION public.create_document_with_deal_link TO authenticated;
GRANT EXECUTE ON FUNCTION public.create_document_with_subject_link TO authenticated;

COMMIT;

-- =====================================================
-- Post-migration notes:
-- - Updated get_active_org_id() to use JWT claim
-- - Created get_clerk_user_id() for easy user ID access
-- - Created generate_tag_slug() for tag slugification
-- - Created linking tables: document_files_deals, document_files_borrowers, document_files_guarantors
-- - Created document_file_deal_ids() to get all deals for a document
-- - Created finalize_document_upload() for post-upload finalization
-- - Created can_access_document() for file-based access control
-- - Created get_deal_documents() to query documents by deal
-- - Created create_document_with_deal_link() for deal document creation
-- - Created create_document_with_subject_link() for pre-deal document creation
-- 
-- NOTE: Some functions reference tables that may not exist yet (borrowers, guarantors)
-- These will be created conditionally or fail gracefully
-- =====================================================
