-- =====================================================
-- Migration: Rename loans → deals and Create deal_roles
-- Date: 2026-01-28
-- Description:
--   - Rename loans table to deals
--   - Create deal_roles table
--   - Update can_access_deal_document() with deal_roles permission check
-- =====================================================

BEGIN;

-- =====================================================
-- PART 1: Rename loans table to deals
-- =====================================================
ALTER TABLE IF EXISTS public.loans RENAME TO deals;

-- Rename indexes (if they exist)
DO $$ 
DECLARE
  r record;
BEGIN
  FOR r IN 
    SELECT indexname 
    FROM pg_indexes 
    WHERE tablename = 'deals' 
      AND indexname LIKE '%loans%'
  LOOP
    EXECUTE format('ALTER INDEX IF EXISTS %I RENAME TO %I',
      r.indexname,
      replace(r.indexname, 'loans', 'deals')
    );
  END LOOP;
END $$;

-- Rename constraints (if they exist)
DO $$ 
DECLARE
  r record;
BEGIN
  FOR r IN 
    SELECT conname 
    FROM pg_constraint 
    WHERE conrelid = 'public.deals'::regclass 
      AND conname LIKE '%loans%'
  LOOP
    EXECUTE format('ALTER TABLE public.deals RENAME CONSTRAINT %I TO %I',
      r.conname,
      replace(r.conname, 'loans', 'deals')
    );
  END LOOP;
END $$;

-- Rename sequence (if it exists)
ALTER SEQUENCE IF EXISTS public.loans_id_seq RENAME TO deals_id_seq;

-- =====================================================
-- PART 2: Update deals_clerk_orgs FK to reference deals
-- =====================================================
ALTER TABLE public.deals_clerk_orgs 
  DROP CONSTRAINT IF EXISTS deals_clerk_orgs_deal_id_fkey;

ALTER TABLE public.deals_clerk_orgs 
  ADD CONSTRAINT deals_clerk_orgs_deal_id_fkey 
    FOREIGN KEY (deal_id) REFERENCES deals(id);

-- =====================================================
-- PART 3: Create deal_roles table
-- =====================================================
CREATE TABLE IF NOT EXISTS public.deal_roles (
  id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  deal_id uuid NULL,
  contact_id bigint NULL,
  deal_role_types_id bigint NULL,
  users_id bigint NULL,
  notes text NULL,
  created_at timestamp with time zone NULL DEFAULT now(),
  CONSTRAINT deal_roles_pkey PRIMARY KEY (id),
  CONSTRAINT deal_roles_users_id_fkey 
    FOREIGN KEY (users_id) REFERENCES users(id) ON DELETE CASCADE,
  CONSTRAINT deal_roles_deal_id_fkey 
    FOREIGN KEY (deal_id) REFERENCES deals(id) ON DELETE CASCADE,
  CONSTRAINT deal_roles_deal_role_types_id_fkey 
    FOREIGN KEY (deal_role_types_id) REFERENCES deal_role_types(id),
  CONSTRAINT deal_roles_has_party CHECK (
    (
      (contact_id IS NOT NULL AND users_id IS NULL)
      OR (contact_id IS NULL AND users_id IS NOT NULL)
      OR (contact_id IS NULL AND users_id IS NULL)
    )
  )
) TABLESPACE pg_default;

-- Add FK to contact table if it exists
DO $$ BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'contact') THEN
    BEGIN
      ALTER TABLE public.deal_roles
        ADD CONSTRAINT deal_roles_contact_id_fkey 
          FOREIGN KEY (contact_id) REFERENCES contact(id) ON DELETE CASCADE;
      RAISE NOTICE 'Added foreign key constraint to contact table';
    EXCEPTION
      WHEN duplicate_object THEN 
        RAISE NOTICE 'deal_roles_contact_id_fkey already exists, skipping';
    END;
  ELSE
    RAISE NOTICE 'contact table does not exist, skipping FK constraint';
  END IF;
END $$;

-- Create indexes for deal_roles
CREATE UNIQUE INDEX IF NOT EXISTS deal_roles_unique_contact_role 
  ON public.deal_roles USING btree (deal_id, deal_role_types_id, contact_id) 
  TABLESPACE pg_default
  WHERE (contact_id IS NOT NULL);

CREATE UNIQUE INDEX IF NOT EXISTS deal_roles_unique_user_role 
  ON public.deal_roles USING btree (deal_id, deal_role_types_id, users_id) 
  TABLESPACE pg_default
  WHERE (users_id IS NOT NULL);

CREATE INDEX IF NOT EXISTS deal_roles_deal_id_idx 
  ON public.deal_roles USING btree (deal_id) 
  TABLESPACE pg_default;

CREATE INDEX IF NOT EXISTS deal_roles_contact_id_idx 
  ON public.deal_roles USING btree (contact_id) 
  TABLESPACE pg_default
  WHERE (contact_id IS NOT NULL);

CREATE INDEX IF NOT EXISTS deal_roles_user_id_idx 
  ON public.deal_roles USING btree (users_id) 
  TABLESPACE pg_default
  WHERE (users_id IS NOT NULL);

CREATE INDEX IF NOT EXISTS deal_roles_role_types_id_idx 
  ON public.deal_roles USING btree (deal_role_types_id) 
  TABLESPACE pg_default;

-- =====================================================
-- PART 4: Update can_access_deal_document() with FULL business logic
-- Now includes deal_roles permission check
-- =====================================================
CREATE OR REPLACE FUNCTION public.can_access_deal_document(
  p_deal_id uuid,
  p_document_category_id bigint,
  p_action text
)
RETURNS boolean
LANGUAGE sql
SECURITY DEFINER
STABLE
AS $$
  SELECT
    CASE
      WHEN p_action NOT IN ('view','insert','upload','delete') THEN false
      ELSE (
        public.is_internal_admin()
        OR (
          public.get_active_org_id() IS NOT NULL

          -- Must be member of active org
          AND EXISTS (
            SELECT 1
            FROM public.organization_members m
            WHERE m.user_id = auth.uid()::text
              AND m.organization_id = public.get_active_org_id()
          )

          -- Deal must belong to active org if mapped
          AND (
            NOT EXISTS (
              SELECT 1
              FROM public.deals_clerk_orgs dorg
              WHERE dorg.deal_id = p_deal_id
            )
            OR EXISTS (
              SELECT 1
              FROM public.deals_clerk_orgs dorg
              WHERE dorg.deal_id = p_deal_id
                AND dorg.clerk_org_id = public.get_active_org_id()
            )
          )

          -- Org-admin bypass only after deal↔org validation
          AND (
            public.is_org_admin(public.get_active_org_id())
            OR EXISTS (
              SELECT 1
              FROM public.deal_roles dr
              JOIN public.document_access_permissions dap
                ON dap.clerk_org_id = public.get_active_org_id()
               AND dap.deal_role_types_id = dr.deal_role_types_id
               AND dap.document_categories_id = p_document_category_id
              WHERE dr.deal_id = p_deal_id
                AND dr.users_id = public.get_current_user_id()
                AND (
                  (p_action = 'view'   AND dap.can_view)
                  OR (p_action = 'insert' AND dap.can_insert)
                  OR (p_action = 'upload' AND dap.can_upload)
                  OR (p_action = 'delete' AND dap.can_delete)
                )
            )
          )
        )
      )
    END;
$$;

COMMIT;

-- =====================================================
-- Post-migration notes:
-- - loans table renamed to deals
-- - All indexes and constraints updated
-- - deals_clerk_orgs FK updated to reference deals
-- - deal_roles table created
-- - can_access_deal_document() updated with FULL business logic
-- - Access control now includes:
--   * Internal admin check
--   * Active org membership
--   * Deal-org mapping validation
--   * Org admin bypass
--   * Deal role permissions with document_access_permissions
-- =====================================================
